package main

import "fmt"

func MapDetail() {
	// map的底层原理
	/*
		todo：map的整体结构


																						#bmap - 桶#
																						8个元素的数组，存储字典每key的哈希值的高8位 tophash
																						8个元素的数组，存储字典key
			 																			8个元素的数组，存储字典value
							#hmap #											 /--------> 指针， 当前通过存不下时创建的溢出桶
			          /  字典的键值对个数 count                      0    ------|
					  |  创建桶的个数为2的B次方                       1    --------
			创建map ->｜  当前map中的桶的数组buckets      --------->  2            \
		              |  哈希因子，用于对key生成hash值 hash           3             \		#bmap - 桶#
					  \  .........								  ...            --->	8个元素的数组，存储字典每key的哈希值的高8位 tophash
																						8个元素的数组，存储字典key
			 																			8个元素的数组，存储字典value
																						指针， 当前通过存不下时创建的溢出桶
	*/

	// 1- 初始化
	info := make(map[string]string, 10)
	/*
			  第一步： 创建一个hmap结构体对象
			  第二步：生成一个哈希因子hash0并赋值到hmap对象中（用于后续为key创建hash值）
			  第三步： 根据hint = 10 ，并根据算法规则来创建B，当前B应该为1
				hit      B
				0-8      0
			    9-13   	 1
			    14-26    2
				........
		     第四步：根据B去创建桶（bmap） 并存放在buckets数组中，当前bmap的数量为2
					当 B< 4 时，根据B创建桶的个数规则为：2**B(标准桶)
					当 B >= 4时，根据B创建桶个数的规则为2**B + 2**（B- 4） ->(标准桶 + 溢出桶)
			注意：每个bmap中可以存储8个键值对，当不够存储时候需要使用溢出桶，并将当前bmap中的overflow字段指向溢出桶的位置
	*/
	fmt.Println(info)

	// 2- 写入数据
	info["name"] = "hany"
	/*
			第一步： 结合hash因子和键name 生成hash值 011000000000344343
			第二步：获取hash值的后B位，并根据后B位的值来确定将此键值对存放在哪个桶中（bmap）
		           将哈希值和桶掩码（B个为1的二进制）进行 & 运算，最终得到hash值的后B为的值，将设B为1时，其结果为0：
		            哈希值：011011100011111101111010
					桶掩码：000000000000000000000000
					结果：  000000000000000000000000  = 0
			第三步： 在上一步确定桶之后，解析来就在桶中写入数据
					获取哈希值的tophash（即，哈希值的"高8位"),
					将tophash、key、value分别写入到桶中的三个数组
					注意： 雨后在桶中查找数据时候，会给予tophash来查找（tophash相同再去比较key）
			第四步：hmap的个数count ++ （map中的元素个数 +1）

	*/

	// 3- 读取数据
	value := info["name"]
	/*
		 第一步： 结合hash因子和键name生成hash值
		 第二步：获取hash值的后B位，并根据后B位的值来确定将此键值对存放在哪个桶中（bmap）
		 第三步：确定桶之后，再根据key的哈希值计算出tophash（高8位），并根据tophash和key去桶中查找数据
				当前桶如果没有找到数据，再根据overflow再去桶中找，均未找到则表示key不存在
	*/
	fmt.Println(value)

	// 4- 扩容
	/*
			 在向map中添加数据时候，当达到某个题哦啊见，则会引发字典扩容
			 扩容条件：
				map中数据总个数 / 桶个数 > 6.5, 引发翻倍扩容
				使用了太多的溢出桶时（溢出桶使用太多回到事map处理速度降低）
					当 B <= 15, 已使用的溢出桶个数 >= 2**B时， 引发等量扩容
					当 B > 15 ，已使用的溢出桶的个数 >= 2**15时，引发等量扩容

																					新桶
					字典的键值对个数 - count                                        -   0
					创建桶的个数位2的B次方 - B										/    1
					哈希因子，用于对key生成hash值 - hash0                           |    2        // 标准桶
					已使用的桶的个数 - noverflow                                   |    3
		 			当前map中的桶的数组（扩容后指向新桶） - buckets    --------------->    4
		创建map----> 扩容后oldbuckets指向原桶oldbuckets              --------------->   ...
					接下来要迁移的桶的编号 -nevacuate                                |   ...      // 溢出桶
					用于处理并发时，是否正在写入 - flags                              |
					扩展字段 - extra												 \  旧桶
								｜                                                 - 0
		                        ｜                                                   1       // 标准桶
		            已经被使用的所有溢出桶的地址数组 - overflow                           ...
					扩容时，原桶已使用的溢出桶的地址数组 - oldoverflow                     3
					指向下一个空闲的溢出桶 - nextOverflow                               ...      // 溢出桶


	*/

	// 5 - 迁移 将旧桶中的数据迁移到新桶中
	/*
		 翻倍扩容：那么迁移规律就是将旧桶中的数据分流至新的两个桶中（比例不定），
		          并且桶编号的位置位：同编号位置和翻倍9i后对应的编号位置

		 如何实现这种迁移：
			首先如果是翻倍扩容（数据总个数 / 桶的个数 > 6.5）则心痛的个数是旧桶的2被，即 map中的B值要+1
		    迁移时候会遍历某个旧桶中所有的key（包括溢出桶）， 并根据key重新生成hash值，
		    根据哈希值的低8位来决定将此键值对分流到哪个新桶中

											扩容前
			1  0  1   0	  1   1  0  1   1   0   0   0   1    1    1   0   1   0  1   1    0  0  1  1  1 ..
		    ------- 高 8 位----------                                              		  ------- 低 8 位----------


											扩容后
			1  0  1   0	  1   1  0  1   1   0   0   0   1    1    1   0   1   0  1   1   0  0  1  1  1 ..
			------- 高 8 位----------                                                  ------- 低 8 位----------


		  扩容后，B值在原来的基础上已加1， 意味着通过多一位来计算此简直对要分流到新桶的位置
				当新增的位的值位0， 则数据会迁移到与旧桶编号一致
				当新增的位的值为1， 则数据会迁移到翻倍后对应便啊后位置
		例子：
			旧桶个数为32个，翻倍后新桶的个数为64。
			在重新计算1日桶中的所有key哈希值时，红色位只能是0或1，所以桶中的所有数据的后B位只能是以下两种情况：
				- 000111 【7】，意味着要迁移到与 1旧桶编号一致的位置。
				- 100111 【39】，意味着会迁移到翻倍后对应编号位置。
			特别提醒：同一个桶中key的哈希值的低B位一定是相同的，不然不会放在同一个桶中，所以同一个桶中黄色标记的位都是相同的。



		等量扩容： 将桶中数据移动到相应的桶中
	*/

}
